{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#python-hooks-a-react-inspired-way-to-code-in-python","title":"Python Hooks, a React inspired way to code in Python.","text":"<ul> <li>\u26a1\ufe0f Written with performance in mind (Not using inspect module)</li> <li>\ud83d\udc0d Support for familiar React like hooks such as <code>use_state</code>, <code>use_effect</code>, <code>use_reducer</code>, <code>use_context</code> and more.</li> <li>\ud83d\udee0\ufe0f Built with plugins support and easy to extend.</li> <li>\ud83e\udd1d Python 3.9+ compatibility</li> <li>\ud83e\udeb6 Lightweight to remove the need for a lot of boilerplate code.</li> <li>\ud83d\udce6 Support for different backend state-stores.</li> <li>\ud83d\udd27 Support for hooks-state scoping.</li> <li>\ud83c\udf0e Redis and Zustand plugins out of the box. </li> <li>\ud83d\udd0c Tested mainly on CPython.</li> </ul>"},{"location":"#api-example","title":"API Example","text":"<p>As Python is commonly used to create APIs, I wanted to provide one real-world example of using hooks for state management in Flask. Note, that this is just one example and the library can be used in many other ways. See examples  for more examples.</p> <p></p> <p>See Getting started for a quick tutorial on how to use the library.</p> <p>See Inspiration for a more in-depth explanation of the motivation behind this project.</p> <p> </p>"},{"location":"async/","title":"Async Support","text":"<p>Lately, support in async / await has been added to Python Hooks. This allows you to write asynchronous code in your hooks.  This is especially useful for hooks that need to make network requests or perform other I/O operations.</p> <p>To use async / await hooks, all you need to do is import your hooks from <code>hooks.asyncio.*</code> instead of <code>hooks.*</code>, and make sure that you are using an async backend, such as <code>hooks.plugins.redis_backend.AsyncRedisBackend</code>.</p> <p>For example:</p> <pre><code>from hooks.asyncio.use import use_state\nfrom hooks.plugins.redis_backend import AsyncRedisBackend\n... \nawait AsyncRedisBackend.use('localhost', 6789)\nasync def use_async_state():\nstate, set_state = await use_state(0)\nawait set_state(state + 1)\nreturn state\n...\nprint(await use_async_state()) # prints 0\nprint(await use_async_state()) # prints 1\n</code></pre>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started","text":"<p>In order to get started with Python Hooks, you need to install the library using pip, note that when installing  the library you install it as <code>python-hooks</code> and not <code>hooks</code> as the latter is already taken in pip. </p> <pre><code>pip install python-hooks\n</code></pre> <p>Once installed you can start using the library, the library is built with plugins support and you can use the built-in plugins or create your own.</p> <pre><code>from hooks import use_state, use_effect\ndef my_stateful_function():\ncount, set_count = use_state(0)\nuse_effect(lambda: print(\"First run\"), [])\nuse_effect(lambda: print(f\"Count, {count}\"), [count]) # (1)\nset_count(count + 1) \nreturn count\nmy_stateful_function() # prints \"First run\" and \"Count, 0\"\nmy_stateful_function() # prints \"Count, 1\"\nmy_stateful_function() # prints \"Count, 2\"\n</code></pre> <ol> <li>\ud83e\udd29 Just like React, use_effect will only run if it's dependencies have changed. In this case, the dependency is the count variable.      This is a very powerful feature as it allows you to control when your code runs.</li> </ol> <p>See Hooks to begin using the built-in hooks.</p>"},{"location":"inspiration/","title":"Inspiration","text":"<p>I'll begin be prefacing that this project will not fit everyone's needs. It's a very opinionated project and it's not meant to be a replacement for any of the existing state management libraries. Additionally, if you are trying to squeeze the most performance out of Python this is probably not the right tool for you (Though you might also be using the wrong programming language).</p> <p>The goal of the project is to provide a simple and familiar way to manage state in Python. It's inspired by the React hooks API and it's meant to be used in a similar way. It can be used to manage  state in a single function or in a large project. The state can be stored in memory, in a database or in a file. It's up to you to decide and the library is easily extendable to support any backend.</p> <p>One of the inspirations for this project was seeing the way junior developers struggle with state management and program structure in Python. This library is intended to provide a sense of familiarity to developers coming from the JavaScript world and to provide a simple way to manage state in Python which will not require a lot of boilerplate code or hurt performance.</p> <p>It is meant to help write better data-driven code and to help developers focus on the business logic of their code rather than on the plumbing.</p> <p>Discord | Github </p> <p></p> <p>Note: This project is still in beta and is not recommended for production use just yet. We are working on adding more tests and improving the documentation. If you are interested in contributing, please reach out to me on Discord.</p> <p>See Getting started for a quick tutorial on how to use the library.</p>"},{"location":"backends/default/","title":"What are backends","text":"<p>Under the hood, Python Hooks uses backend objects to store the state of hooks. This provides a way to persist state in different ways by using different backends. By default, Python Hooks uses the <code>MemoryBackend</code> to store state in memory, but you can also use the <code>RedisBackend</code> to store state in Redis, or you can create your own custom backend to store state in any way you want.</p>"},{"location":"backends/default/#backends-available-out-of-the-box","title":"Backends available out of the box:","text":"<ul> <li>MemoryBackend - Pickled state stored in memory</li> <li>RedisBackend - Pickled state stored in Redis</li> <li>ThreadsafeBackend - Pickled state stored in a thread local data structure</li> </ul>"},{"location":"backends/default/#changing-the-default-backend","title":"Changing the default backend","text":"<p>Changing the in-use backend is super easy. </p> <pre><code>from hooks.backends import ThreadsafeBackend\nThreadsafeBackend.use()\n# Any hooks created after this point will use the ThreadsafeBackend\n</code></pre> <p>or for using Redis:</p> <pre><code>from hooks.backends import RedisBackend\nRedisBackend.use(\"localhost\", 6379, db=0)\n# Any hooks created after this point will use the RedisBackend\n</code></pre>"},{"location":"backends/default/#creating-a-custom-backend","title":"Creating a custom backend","text":"<p>You can create a custom backend by just inheriting from the <code>HooksBackend</code> class and implementing subset of the methods defined in the <code>HooksBackend</code> class. </p>"},{"location":"hooks/additional_hooks/custom_hooks/","title":"Custom Hooks","text":"<p>Sometimes it would make sense to write custom hooks. For example, you may want to create a custom hook to fetch data  from a database or to fetch data from a file. Or you might want to write a custom hook that combines functionality from multiple hooks. </p> <p>To do this, it's very simple. Just write a function that it's name starts with <code>use_</code> and it will be treated as a hook. For example, let's say we want to write a custom hook that combines the functionality of <code>use_state</code> and <code>use_effect</code>:</p> <pre><code>from hooks import use_state, use_effect\nfrom hooks.utils import destruct\ndef use_state_and_effect(initial_state: int):\nstate, set_state = use_state(initial_state)\ndef effect():\nprint(\"State changed: \", state)\nuse_effect(effect, [state])\n# Returning in a dict just as an example for using destruct (The util will work on any object)\nreturn {\n\"state\": state,\n\"set_state\": set_state\n}\nset_state = destruct(use_state_and_effect(0))[\"set_state\"]\nset_state(1)\nset_state(2)\nset_state(3)\n</code></pre> <p>Note: You have to use the <code>use_</code> prefix in order for the hook to be treated as a hook. Otherwise, it will be treated as a normal function and will not be able to identify where to store the state inside the backend.</p>"},{"location":"hooks/additional_hooks/custom_hooks/#next-steps","title":"Next steps","text":"<p>Learn about scoping hooks with hooks_scope decorator.</p>"},{"location":"hooks/additional_hooks/use_reducer/","title":"use_reducer Hook","text":"<p>Here is where things get interesting. The <code>use_reducer</code> hook is used to manage state in a functional way. It is similar to the <code>use_state</code> hook but allows us to manage more complex state.</p>"},{"location":"hooks/additional_hooks/use_reducer/#basic-use","title":"Basic use","text":"<p>Using the <code>use_reducer</code> hook is very similar to reducer concepts in other frameworks. The hook takes in a reducer function and an initial state. Intern, the hook returns a tuple containing the current state and a dispatch function. The dispatch function is used to dispatch actions to the reducer function.</p> <pre><code>from hooks import use_reducer\ndef tasks_reducer(current_state: dict, action: dict) -&gt; dict:\nif action[\"type\"] == \"ADD_TASK\":\nreturn {\"tasks\": current_state[\"tasks\"] + [action[\"task\"]]}\nreturn current_state\nstate, dispatch = use_reducer(tasks_reducer, {\"tasks\": []})\nnew_state = dispatch({\"type\": \"ADD_TASK\", \"task\": \"Do the dishes\"})\nprint(state)  # Output: {\"tasks\": []}\nprint(new_state)  # Output: {\"tasks\": [\"Do the dishes\"]}\n</code></pre> <p>The dispatch function can be used to dispatch actions from anywhere in the application. This allows us to manage the state in a centralised location. In addition, the use_reducer hook can be used multiple times in the same application and even in the same function. It knows to identify the correct state to update based on the reducer function passed in.</p>"},{"location":"hooks/additional_hooks/use_reducer/#accessing-the-state-in-separate-functions","title":"Accessing the state in separate functions","text":"<p>You may use the <code>use_reducer</code> hook in separate functions and still access the same state. This is because the hook uses the same reducer function to identify the state to update. This is useful when you want to separate your logic into different functions.</p> <pre><code>from hooks import use_reducer\ndef tasks_reducer(current_state: dict, action: dict) -&gt; dict:\nif action[\"type\"] == \"ADD_TASK\":\nreturn {\"tasks\": current_state[\"tasks\"] + [action[\"task\"]]}\nreturn current_state\ndef add_task(task: str):\nstate, dispatch = use_reducer(tasks_reducer, {\"tasks\": []})\ndispatch({\"type\": \"ADD_TASK\", \"task\": task})\ndef get_tasks():\nstate, dispatch = use_reducer(tasks_reducer)\nreturn state[\"tasks\"]\nadd_task(\"Do the dishes\")\nadd_task(\"Do the laundry\")\nprint(get_tasks())  # Output: [\"Do the dishes\", \"Do the laundry\"]\n</code></pre>"},{"location":"hooks/additional_hooks/use_reducer/#middleware","title":"Middleware","text":"<p>The <code>use_reducer</code> hook also supports middleware. Middleware is a function that is called before the reducer processes the action. This allows you to perform actions such as logging or analytics before the reducer processes the action.</p> <pre><code>from hooks import use_reducer\ndef logging_middleware(state: dict, process: Callable, action: dict) -&gt; dict:\nprint(\"Action: \", action)\nnew_state: dict = process(state, action)\nprint(\"New state: \", new_state)\nreturn new_state\ndef tasks_reducer(current_state: dict, action: dict) -&gt; dict:\nif action[\"type\"] == \"ADD_TASK\":\nreturn {\"tasks\": current_state[\"tasks\"] + [action[\"task\"]]}\nreturn current_state\nstate, dispatch = use_reducer(tasks_reducer, {\"tasks\": []}, [logging_middleware])\ndispatch({\"type\": \"ADD_TASK\", \"task\": \"Do the dishes\"})\n# Output: Action: {\"type\": \"ADD_TASK\", \"task\": \"Do the dishes\"}\n#         New state: {\"tasks\": [\"Do the dishes\"]}\n</code></pre> <p>You may add as many middleware functions as you like. The middleware functions are called in the order they are provided.</p>"},{"location":"hooks/additional_hooks/use_reducer/#combining-reducers","title":"Combining reducers","text":"<p>You may also combine multiple reducers into one using the <code>combine_reducers</code> function. This is useful when you want to split your state into multiple reducers.</p> <pre><code>from hooks import use_reducer, combine_reducers\ndef tasks_reducer(current_state: dict, action: dict) -&gt; dict:\nif action[\"type\"] == \"ADD_TASK\":\nreturn {\"tasks\": current_state[\"tasks\"] + [action[\"task\"]]}\nreturn current_state\ndef user_reducer(current_state: dict, action: dict) -&gt; dict:\nif action[\"type\"] == \"SET_USER\":\nreturn {\"user\": action[\"user\"]}\nreturn current_state\ncombined_reducer = combine_reducers(tasks_reducer, user_reducer)\nstate, dispatch = use_reducer(combined_reducer, {\"tasks\": [], \"user\": None})\ndispatch({\"type\": \"ADD_TASK\", \"task\": \"Do the dishes\"})\nnew_state = dispatch({\"type\": \"SET_USER\", \"user\": \"John Doe\"})\nprint(new_state)  # Output: {\"tasks\": [\"Do the dishes\"], \"user\": \"John Doe\"}\n</code></pre> <p>The <code>combine_reducers</code> function takes in multiple reducer functions and returns a single reducer function. The returned reducer function will call each reducer function with the current state and action. The returned reducer function will then combine the results of each reducer function into a single state.</p>"},{"location":"hooks/additional_hooks/use_reducer/#next-steps","title":"Next steps","text":"<p>Learn about creating custom hooks.</p> <p>Learn about scoping hooks with hooks_scope decorator.</p>"},{"location":"hooks/base_hooks/use_context/","title":"use_context Hook","text":"<p>The <code>use_context</code> hook allows you to access context from anywhere in your program. This is useful for accessing global state.</p> <p>Differentiating from the rest of the basic hooks, <code>use_context</code> comes along with two other functions <code>create_context</code> and <code>set_context_value</code>.</p> <p><code>use_context</code> is used to access the context value.  <code>create_context</code> is used to create a context object.  <code>set_context_value</code> is used to set the context value.</p> <p>Context, like all hooks, is affected by scoping. This means that context is only accessible within the scope of the function that created (!) it. Read more about scoping hooks with hooks_scope decorator.</p>"},{"location":"hooks/base_hooks/use_context/#creating-and-using-a-context","title":"Creating and using a context","text":"<pre><code>from hooks import create_context, use_context\nmy_context = create_context(\"Initial value\")\nprint(use_context(my_context))  # Output: Initial value\n</code></pre> <p>This is a simple example of creating a context and accessing it with <code>use_context</code>. Pretty boring, right?  Let's make it more interesting.</p>"},{"location":"hooks/base_hooks/use_context/#setting-a-context-value","title":"Setting a context value","text":"<pre><code>from hooks import create_context, use_context, set_context_value\nmy_context = create_context(\"Initial value\")\nprint(use_context(my_context))  # Output: Initial value\nset_context_value(my_context, \"New value\")\nprint(use_context(my_context))  # Output: New value\n</code></pre> <p>Okay, so now we know how to set a context value. But this is still pretty boring. Let's see how we can use this in a  real program.</p>"},{"location":"hooks/base_hooks/use_context/#using-context-in-a-real-program","title":"Using context in a real program","text":"<pre><code>from hooks import create_context, use_context, set_context_value\nmy_context = create_context(\"Initial value\")\ndef my_stateful_function() -&gt; None:\nprint(use_context(my_context))\nreturn\nmy_stateful_function()  # Output: Initial value\nset_context_value(my_context, \"New value\")\nmy_stateful_function()  # Output: New value\n</code></pre> <p>Now this is a bit more interesting. We can see that the context value is updated when we call <code>set_context_value</code> and that the value is accessible from anywhere in the program. </p>"},{"location":"hooks/base_hooks/use_context/#why-is-this-useful","title":"Why is this useful?","text":"<p>Context is useful for storing global state. This is useful for storing things like the current user, the current theme, or the current language. </p> <p>It is also used as a building block for plugins like <code>Zustand</code> and <code>Redux</code>.</p>"},{"location":"hooks/base_hooks/use_context/#next-steps","title":"Next steps","text":"<p>Learn about additional hooks.</p> <p>Learn about scoping hooks with hooks_scope decorator. </p>"},{"location":"hooks/base_hooks/use_effect/","title":"use_effect Hook","text":"<p>The <code>use_effect</code> hook allows us to run code when the state of the program changes. This is useful for running code when the program starts, or when the user interacts with the program, or it's dependencies change.</p>"},{"location":"hooks/base_hooks/use_effect/#basic-use","title":"Basic use","text":"<pre><code>use_effect(lambda: print(\"Hello World\"), [])\n</code></pre> <p>The <code>use_effect</code> hook takes two arguments. The first argument is a function which will be called when the state of the program changes. The second argument is a list of dependencies. The function will only be called when the dependencies change and at least once when the program starts.</p> <p>Let's see an example:</p> <pre><code>from hooks import use_effect\ndef my_stateful_function() -&gt; None:\n# Will only print \"Hello World\" once, during the first function call\nuse_effect(lambda: print(\"Hello World\"), [])\nreturn\nmy_stateful_function()  # Output: Hello World\nmy_stateful_function()  # Output: \nmy_stateful_function()  # Output: \n</code></pre>"},{"location":"hooks/base_hooks/use_effect/#dependencies","title":"Dependencies","text":"<p>The second argument to <code>use_effect</code> is a list of dependencies. The function will only be called when the dependencies change and at least once when the program starts.</p> <pre><code>from hooks import use_effect\ndef my_stateful_function(name: str) -&gt; None:\n# Will only print \"Hello, {name}\" when the name changes\nuse_effect(lambda: print(f\"Hello, {name}\"), [name])\nreturn\nmy_stateful_function(\"John\")  # Output: Hello, John\nmy_stateful_function(\"John\")  # Output:\nmy_stateful_function(\"Jane\")  # Output: Hello, Jane\nmy_stateful_function(\"Jane\")  # Output:\n</code></pre> <p>As you can see in the example above, the function is only called when the name changes. This is akin to caching the result of the function using something like functool's <code>lrucache</code>. The main difference is that you may cache different actions inside the function instead of the entire function itself which is pretty neat.</p>"},{"location":"hooks/base_hooks/use_effect/#as-a-decorator","title":"As a decorator","text":"<p>The <code>use_effect</code> hook can also be used as a decorator. This is useful when your use_effect hook is longer than a single line.</p> <pre><code>from hooks import use_effect\ndef my_stateful_function(name: str) -&gt; None:\n@use_effect(dependencies=[name], decorating=True)\ndef my_effect():\nprint(f\"Hello, {name}\")\nreturn\nmy_stateful_function(\"John\")  # Output: Hello, John\nmy_stateful_function(\"John\")  # Output:\nmy_stateful_function(\"Jane\")  # Output: Hello, Jane\nmy_stateful_function(\"Jane\")  # Output:\n</code></pre>"},{"location":"hooks/base_hooks/use_effect/#next-steps","title":"Next steps","text":"<p>Learn the next basic hook: use_context</p>"},{"location":"hooks/base_hooks/use_state/","title":"use_state Hook","text":"<p>The <code>use_state</code> hook is the most basic hook in the library. It allows you to store state in a function. It's similar to the <code>useState</code> hook in React. All other hooks are built on top of this hook.</p>"},{"location":"hooks/base_hooks/use_state/#basic-use","title":"Basic use","text":"<p>Let learn about <code>use_state</code>: <pre><code>count, set_count = use_state(0)\n</code></pre></p> <p><code>use_state</code> will always return a tuple of the current state and a function to update the state. The state can be any type, it can be a string, a number, a list or a dictionary.</p> <p>The state will automatically be persisted between function calls. See Default Scoping for more information on how the state is persisted.</p> <p>Let's see an example:</p> <pre><code># We import the use_state hook from the hooks module\nfrom hooks import use_state\ndef my_stateful_function() -&gt; int:\n# We call the use_state hook and store the result in a variable called count and set_count\ncount, set_count = use_state(0)\n# We mutate the state by adding 1 to the current count\nset_count(count + 1) \nreturn count\nprint(my_stateful_function()) # Output: 0\nprint(my_stateful_function()) # Output: 1\nprint(my_stateful_function()) # Output: 2\n</code></pre> <p>As you can see, the state is persisted between function calls. This is because the state is stored in the function's scope. By default, the state is persisted only for the duration of the program. If you run the program again, the state will be reset. State may be persisted for longer periods of time by using a different backend.</p>"},{"location":"hooks/base_hooks/use_state/#multiple-state-hooks","title":"Multiple state hooks","text":"<p>Additionally, we can use multiple <code>use_state</code> hooks in a single function. This allows us to store multiple pieces of state in a single function.</p> <pre><code>from hooks import use_state\ndef my_stateful_function() -&gt; tuple[int, str]:\ncount, set_count = use_state(0)\nname, set_name = use_state(\"John\")\nset_count(count + 1)\nset_name(\"Jane\")\nreturn count, name\nprint(my_stateful_function()) # Output: (0, \"John\")\nprint(my_stateful_function()) # Output: (1, \"Jane\")\nprint(my_stateful_function()) # Output: (2, \"Jane\")\n</code></pre>"},{"location":"hooks/base_hooks/use_state/#state-hooks-inside-objects","title":"State hooks inside objects","text":"<p>We can also use <code>use_state</code> hooks inside objects. This allows us to store state which is persisted for the lifetime of the object.</p> <pre><code>from hooks import use_state\nclass MyObject:\ndef object_persisted_count(self):\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\nobj = MyObject()\nprint(obj.object_persisted_count())          # Output: 0\nprint(obj.object_persisted_count())          # Output: 1\nmy_other_obj = MyObject()\nprint(my_other_obj.object_persisted_count()) # Output: 0\n</code></pre>"},{"location":"hooks/base_hooks/use_state/#class-methods-and-static-methods","title":"Class methods and static methods","text":"<p>The <code>use_state</code> hook can also be used inside class methods and static methods. This allows us to store state which is persisted for the lifetime of the class.</p> <pre><code>from hooks import use_state\nclass MyClass:\n@classmethod\ndef class_persisted_count(cls):\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\n@staticmethod\ndef static_persisted_count():\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\nprint(MyClass.class_persisted_count())  # Output: 0\nprint(MyClass.class_persisted_count())  # Output: 1\nprint(MyClass.static_persisted_count()) # Output: 0\nprint(MyClass.static_persisted_count()) # Output: 1\n</code></pre> <p>Note: the inner workings of hooks are not dependent on the naming of the arguments, meaning you do not have to name the instance or class arguments <code>self</code> and <code>cls</code> for the hooks to work. You can name them whatever you want.</p>"},{"location":"hooks/base_hooks/use_state/#thread-safety-of-state-hooks","title":"Thread safety of state hooks","text":"<p>The <code>use_state</code> hook is currently not threadsafe. The reason being that the default backend is not threadsafe in order to maximize compatibility with different frameworks such as Flask. If you need to use <code>use_state</code> in a  multithreaded environment you should use the <code>threadsafe</code> backend. See Backends for more information.</p>"},{"location":"hooks/base_hooks/use_state/#next-steps","title":"Next steps","text":"<p>Learn the next basic hook: use_effect</p>"},{"location":"plugins/redux/","title":"Redux","text":"<p>The Redux plugin is a state management plugin that provides a familiar API for Redux users.</p> <p>It provides one global store that can be used by any function to get and set state.</p>"},{"location":"plugins/redux/#installation","title":"Installation","text":"<pre><code>pip install python-hooks[redux]\n</code></pre>"},{"location":"plugins/redux/#usage","title":"Usage","text":"<pre><code>from hooks import combine_reducers\nfrom hooks.plugins.redux import create_redux_store, use_dispatch, use_selector\ndef tasks_reducer(current_state: dict, action: dict) -&gt; dict:\nif action[\"type\"] == \"ADD_TASK\":\nreturn {\"tasks\": current_state[\"tasks\"] + [action[\"task\"]]}\nreturn current_state\ndef user_reducer(current_state: dict, action: dict) -&gt; dict:\nif action[\"type\"] == \"SET_USER\":\nreturn {\"user\": action[\"user\"]}\nreturn current_state\ncombined_reducer = combine_reducers(tasks_reducer, user_reducer)\ncreate_redux_store(combined_reducer, {\"tasks\": [], \"user\": None})\ndef test_basic_get_and_set() -&gt; None:\ndispatch = use_dispatch()\nprint(use_selector(lambda state: state.tasks))      # Output: []\ndispatch({\"type\": \"ADD_TASK\", \"task\": \"Do the dishes\"})\nprint(use_selector(lambda state: state.tasks))      # Output: [\"Do the dishes\"]\n</code></pre>"},{"location":"plugins/zustand/","title":"Zustand","text":"<p>The Zustand plugin is a state management plugin that is inspired by the Zustand library.</p> <p>It is basically a wrapper around <code>use_context</code> to provide a more familiar API for Zustand users.</p>"},{"location":"plugins/zustand/#installation","title":"Installation","text":"<pre><code>pip install python-hooks[zustand]\n</code></pre>"},{"location":"plugins/zustand/#usage","title":"Usage","text":"<pre><code>from hooks.plugins.zustand import create\nuse_bear_store = create(\n{\n\"bear\": \"\ud83d\udc3b\",\n},\nlambda set, get: (\n{\n\"increase_bears\": lambda: set(lambda state: {**state, \"bear\": \"\ud83d\udc3b\ud83d\udc3b\"}),\n}\n),\n)\ndef test_basic_get_and_set() -&gt; None:\nprint(use_bear_store(lambda state: state.bear))  # Output: \"\ud83d\udc3b\"\nincrease_bears = use_bear_store(lambda state: state.increase_bears)\nincrease_bears()\nprint(use_bear_store(lambda state: state.bear))  # Output: \"\ud83d\udc3b\ud83d\udc3b\"\n</code></pre>"},{"location":"scoping/default_scoping/","title":"Default Scoping","text":"<p>By default, hooks are scoped to the smallest enclosing scope. This means that if you call a hook inside a function, the hook will only be scoped to that function. If you call a hook inside a class, the hook will only be scoped to that class. If you call a hook inside a module, the hook will only be scoped to that module.</p> <p>Hooks scoping mechanism attempts to work in a very predictable way in order to avoid unexpected behavior. </p> <p>Here is an example of how hooks are scoped to the smallest enclosing scope:</p> <pre><code>from hooks import use_state\ndef get_tasks():\nstate, set_state = use_state({\"tasks\": []})\nreturn state[\"tasks\"]\nprint(get_tasks())  # Output: []\ndef add_task(task: str):\nstate, set_state = use_state()\nset_state({\"tasks\": state[\"tasks\"] + [task]})\nadd_task(\"Do the dishes\")\nadd_task(\"Do the laundry\")\nprint(get_tasks())  # Output: []\n</code></pre> <p>As you can see in the example above, the <code>get_tasks</code> function is scoped to the <code>get_tasks</code> function, and the <code>add_task</code> function is scoped to the <code>add_task</code> function. This means that the <code>get_tasks</code> function will always return an empty list, and the <code>add_task</code> function will always add a task to an empty list.</p>"},{"location":"scoping/default_scoping/#class-scopes","title":"Class scopes","text":"<p>When using hooks inside a class, the scope by default will be limited to that class according to the type of method that the hook is called in. For example, if you call a hook inside a <code>classmethod</code>, the hook will be scoped to the class and not the instance. If you call a hook inside an <code>instancemethod</code>, the hook will be scoped to the instance and not the class. If you call a hook inside a <code>staticmethod</code>, the hook will be scoped globally.</p> <pre><code>from hooks import use_state\nclass CounterClass:\ndef instance_counter(self):\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\n@classmethod\ndef class_counter(cls):\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\n@staticmethod\ndef static_counter():\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\ncounter = CounterClass()\nprint(counter.instance_counter())         # Output: 0\nprint(counter.instance_counter())         # Output: 1\nprint(CounterClass().instance_counter())  # Output: 0\nprint(CounterClass().instance_counter())  # Output: 0\nprint(CounterClass.class_counter())       # Output: 0\nprint(CounterClass.class_counter())       # Output: 1\nprint(CounterClass.static_counter())      # Output: 0\n</code></pre> <p>As you can see the default scoping mechanism for hooks inside a class is to scope the hook to the smallest enclosing scope and is predictable. However, you may want to change the default scoping mechanism for hooks inside a class. You can do this by using the hooks_scope decorator.</p>"},{"location":"scoping/default_scoping/#scopes-and-function-parameters","title":"Scopes and function parameters","text":"<p>When using hooks inside a function, the scope by default will ignore function parameters. This means that if you call a hook inside a function, the hook will be scoped to the function and not the function parameters (Unless when using  parameters as dependencies on use_effect).</p> <pre><code>from hooks import use_state\ndef get_count(other_param: str):\ncount, set_count = use_state(0)\nset_count(count + 1)\nprint(other_param)\nreturn count\nprint(get_count(\"Hello\"))  # Output: 0\nprint(get_count(\"World\"))  # Output: 1\nprint(get_count(\"This wont affect the state\"))  # Output: 2\n</code></pre>"},{"location":"scoping/default_scoping/#next-steps","title":"Next steps","text":"<p>Learn about scoping hooks with hooks_scope decorator.</p>"},{"location":"scoping/scope_decorator/","title":"Scope Decorator","text":"<p>The <code>@hook_scope</code> decorator is used to define a scope for your hooks. It is useful for two main use cases:</p> <ul> <li>When you want to persist state based on function parameters.</li> <li>When you want to scope hooks in a method globally instead of to the instance or class.</li> </ul>"},{"location":"scoping/scope_decorator/#scoping-state-to-function-parameters","title":"Scoping state to function parameters","text":"<p>When using hooks inside a function, the scope by default will ignore function parameters. This means that if you call a hook inside a function, the hook will be scoped to the function and not the function parameters (Unless when using parameters as dependencies on use_effect).</p> <p>You can use the <code>@hook_scope</code> decorator to scope hooks to function parameters. This is useful when you want to persist state based on function parameters.</p> <pre><code>from hooks import use_state, hook_scope\n@hook_scope(parametrize=[\"owner\"])\ndef owned_counter(owner: str):\ncount, set_count = use_state(0)\nset_count(count + 1)\nprint(f\"{owner}'s count is {count}\")\nowned_counter(\"John\")  # Output: John's count is 0\nowned_counter(\"John\")  # Output: John's count is 1\nowned_counter(\"Jane\")  # Output: Jane's count is 0\nowned_counter(\"Jane\")  # Output: Jane's count is 1\n</code></pre> <p>Note that you do not have to provide a value for the <code>parametrize</code> parameter. If you do not provide a value, the hook will be scoped to all function parameters.</p> <pre><code>from hooks import use_state, hook_scope\n@hook_scope()\ndef owned_counter(owner: str):\ncount, set_count = use_state(0)\nset_count(count + 1)\nprint(f\"{owner}'s count is {count}\")\nowned_counter(\"John\")  # Output: John's count is 0\nowned_counter(\"John\")  # Output: John's count is 1\nowned_counter(\"Jane\")  # Output: Jane's count is 0\nowned_counter(\"Jane\")  # Output: Jane's count is 1\n</code></pre>"},{"location":"scoping/scope_decorator/#scoping-hooks-globally","title":"Scoping hooks globally","text":"<p>When using hooks inside a class, the default scoping mechanism is to scope the hook to the smallest enclosing scope. Sometimes, you'll want to scope hooks globally instead of to the instance or class. You can do this by using the <code>@hook_scope</code> decorator.</p> <pre><code>from hooks import use_state, hook_scope\nclass CounterClass:\n@hook_scope(use_global_scope=True, parametrize=[])\ndef instance_method_scoped_globally(self):\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\ndef instance_method(self):\ncount, set_count = use_state(0)\nset_count(count + 1)\nreturn count\ncounter = CounterClass()\ncounter_two = CounterClass()\nprint(counter.instance_method())                      # Output: 0\nprint(counter.instance_method())                      # Output: 1\nprint(counter_two.instance_method())                  # Output: 0\nprint(counter.instance_method_scoped_globally())      # Output: 0\nprint(counter_two.instance_method_scoped_globally())  # Output: 1\n</code></pre> <p>Note that when using <code>use_global_scope=True</code>, you have to provide a value for the <code>parametrize</code> parameter. You may provide an empty list if you want to scope the hook to no parameters.</p>"},{"location":"scoping/scope_decorator/#nesting-scopes","title":"Nesting scopes","text":"<p>As you might be aware hooks can be used anywhere and you may have functions that use hooks and are called by other functions that use hooks. When nesting hooks like this, scoping will affect all hooks in the call stack.</p> <pre><code>from hooks import use_state, hook_scope\nclass NestedStates:\ndef nested_state(self) -&gt; int:\ncounter, set_counter = use_state(0)\nset_counter(counter + 1)\nreturn counter\n@hook_scope(parametrize=[\"counter_name\"])\ndef local_state(self, counter_name: str) -&gt; int:\nreturn self.nested_state()\nfoo = NestedStates()\nprint(foo.local_state(\"A\"))            # Output: 0\nprint(foo.local_state(\"A\"))            # Output: 1\n# As you can see the scope of local_state affects the nested_state's function hooks.\nprint(foo.local_state(\"B\"))            # Output: 0\nprint(foo.local_state(\"B\"))            # Output: 1\nprint(foo.local_state(\"A\"))            # Output: 2\nprint(NestedStates().local_state(\"A\")) # Output: 0\nprint(NestedStates().local_state(\"A\")) # Output: 0\n</code></pre> <p>The same concept can be taken further by scoping the nested_state function.</p> <pre><code>from hooks import use_state, hook_scope\nclass NestedStates:\n@hook_scope()\ndef nested_state_with_scope(self) -&gt; int:\ncounter, set_counter = use_state(0)\nset_counter(counter + 1)\nreturn counter\n@hook_scope(parametrize=[\"counter_name\"])\ndef local_state(self, counter_name: str) -&gt; int:\nreturn self.nested_state_with_scope()\nfoo = NestedStates()\nprint(foo.local_state(\"A\"))             # Output: 0\nprint(foo.local_state(\"A\"))             # Output: 1\nprint(foo.local_state(\"B\"))             # Output: 0\nprint(foo.local_state(\"B\"))             # Output: 1\nprint(foo.local_state(\"A\"))             # Output: 2\nprint(NestedStates().local_state(\"A\"))  # Output: 0\nprint(NestedStates().local_state(\"A\"))  # Output: 0\n</code></pre>"},{"location":"scoping/scope_decorator/#next-steps","title":"Next steps","text":"<p>Learn about backends.</p>"}]}